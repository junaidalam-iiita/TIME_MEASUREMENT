/* This Header file contains the Global-Variables & the Classes and Utility-Functions necessary to implement our Data-Auditing Protocol */

#include"generalUtility.h"

//////////////////////////////////                       GLOBAL VARIABLES   /////////////////////////////////////////////////////////////////////////////////////////////


// data-file sector-size (in bytes) - can be anything less than the size of the file
size_t SECSIZE; 

// no. of sectors per block - can be anything less than total no. of sectors in the file = filesize / sector-size
size_t SECPERBLOCK;

size_t k1; // size of 'p' (and all elements of Zp*) (in bits)
size_t k2; // size of 'q' (and all elements of Fq) (in bits)

// Percentage of blocks to be challenged
double AUDIT_PERCENT;

// whether to print the messages on monitor by the programs, except the last program
bool debug;

//  whether to print the messages on monitor by the last program
bool lastProgramDebug;

//  whether to print only the execution-times
bool timeDebug;

// Size of one block (in bytes)

size_t BLOCKSIZE;

// size of 'p' (and all elements of Zp*) (in bytes)
size_t ENCODESIZE_1;

// size of 'q' (and all elements of Fq) (in bytes)

size_t ENCODESIZE_2;

// Size of one Tag (in bytes)
size_t TAGSIZE;

string statFileName = "Statistics.txt";

ofstream statFile;

//////////////////////////////////                       PROTOTYPES OF ALL CLASSES    /////////////////////////////////////////////////////////////////////////////////////////////

/* Class For Efficient Handling of the DataAudit Protocol Global parameters  */
class GlobalParams{
	public:
	// List of all param vales . 
	Integer p, q, g;
	vector<Integer> h_Values;
	
	// Function to load the param values from a specified params-file
	void LoadValuesFromFile(ifstream& params_file);
	
	// Function to save the param values into a specified params-file
	void SaveValuesToFile(ofstream& params_file);

	// Function to print the param values 
	void PrintValues();
};

/* Class For Efficient Handling of the DataAudit Protocol Proof-of-Possession(POP) Data   */
class PP_PoPData{
	public:
	
	Integer getData();
	
	void setData(Integer x);
	
	void LoadValuesFromFile(ifstream& pop_file);
	
	void SaveValuesToFile(ofstream& pop_file); 
	
	void PrintValues();
	
	private:
	Integer PROOF;
};

/* Class which Generates Random elements in Fq based on a given seed string.
Note that the sequence of elements generated by an object of this class is UNIQUE if the seed string remains the same. */
class getRandomFq{
	public:
	
	// Takes the seed string and the value of 'q' to create an obejct
	getRandomFq(string seed_str, Integer modulus);
	
	// Returns a random elelemnt in Fq
	Integer getElement();
	
	private:
	string input_to_hash, str1, str2;
    	size_t var = 0;
    	size_t hashedLength = 2;
    	unsigned char * hashedData;
    	Integer q;
};

/* Class which Generates Random elements in Zn based on a given seed string.
Note that the sequence of elements generated by an object of this class is UNIQUE if the seed string remains the same. */

class getRandomZn{
	public:
	
	// Takes the seed string and the value of 'n' to create an obejct
	getRandomZn(string seedStr, size_t n);
	
	// Returns a random elelemnt in Zn.
	size_t getElement();
	
	/* Returns a random elelemnt in Zn. 
	However, unlike the previous function, successive calls to this function never repeats any previously generated element.
	Hence, an object can return max. 'n' values */
	size_t getElementUnique();
	
	private:
	unsigned int seed;
	size_t max;
	std::mt19937 rng1, rng2;
	std::uniform_int_distribution<size_t> dist;
	std::set<size_t> uniqueNumbers;
	size_t c;
};

///////////////////////////////////////     PROTOTYPES OF ALL GLOBAL FUNCTIONS /////////////////////////////////////////////////////////////////////////

/* Decodes the given 'binaryData' as a Cryptopp::Integer, maps the Integer value into Fq and returns the value.
Becomes useful in converting the sectors of a data-file into elements in Fq 
*/
Integer MapWordToFiniteField(const  unsigned char* binaryData, size_t dataSize, Integer q);


// Extracts the sectors from the given binaryBlock and converts each sector-data into an element in Fq and returns the vector of Fq elements
vector<Integer> ConvertSectorsInFq(char * binaryBlock, size_t blocksize, size_t sectorSize, Integer q);

vector<vector<Integer>>  GenerateKeyMatrix(Integer alpha, size_t r, MyFiniteField& Fq);
	/* This function expands a given key (alpha) as column matrix with 'r' rows, where the first row is the alpha itself, the 2nd row is the square of it, the 3rd row is the cube of it etc. All the operations are performed in the given finite filed Fq 
	Returns <alpha, alpha^2, ..., alpha^s> as a column matrix */












////////////////////////////////////               IMPLEMENTATATION OF THE CLASS MEMBER FUNCTIONS ////////////////////////////////////////////////////////////////////////////




/*                          Member Functions of the GlobalParams Class                   */

void GlobalParams::LoadValuesFromFile(ifstream& params_file){
	p = LoadIntegerFromBinaryFile(params_file, ENCODESIZE_1);
	g = LoadIntegerFromBinaryFile(params_file, ENCODESIZE_1);
	q = LoadIntegerFromBinaryFile(params_file, ENCODESIZE_2);
	
	for(size_t j = 0; j < SECPERBLOCK; j++){
		h_Values.push_back( LoadIntegerFromBinaryFile(params_file, ENCODESIZE_1)  );
	}
}

void GlobalParams::SaveValuesToFile(ofstream& params_file){
	SaveIntegerToBinaryFile(p, params_file, ENCODESIZE_1);
	SaveIntegerToBinaryFile(g, params_file, ENCODESIZE_1);
	SaveIntegerToBinaryFile(q, params_file, ENCODESIZE_2);
	
	for(size_t j = 0; j < SECPERBLOCK; j++){
		SaveIntegerToBinaryFile(h_Values[j], params_file, ENCODESIZE_1);
	}
}

void GlobalParams::PrintValues(){
	cout << "Param Values: " << endl;
	cout << "p = " << p  << endl;
	cout << "g = " << g  << endl;
    	cout << "q = " << q  << endl;
    	for(size_t j = 0; j < SECPERBLOCK; j++){
		cout << "h" << (j+1) << " = " << h_Values[j]  << endl;
	}
}

/*                          Member Functions of the PP_PoPData Class                   */
	
Integer PP_PoPData::getData(){
	return PROOF;
}

void PP_PoPData::setData(Integer x){
	PROOF = x;
}
	
void PP_PoPData::LoadValuesFromFile(ifstream& pop_file){
	PROOF = LoadIntegerFromBinaryFile(pop_file, ENCODESIZE_1);
}
	
void PP_PoPData::SaveValuesToFile(ofstream& pop_file){
	SaveIntegerToBinaryFile(PROOF, pop_file, ENCODESIZE_1);
} 
	
void PP_PoPData::PrintValues(){
	cout << "POP Value = " << PROOF << endl;
}


/*                          Member Functions of the getRandomZn Class                   */


getRandomZn::getRandomZn(string seedStr, size_t n){
	string hashed = computeSHA256( reinterpret_cast<unsigned char*>(const_cast<char*>(seedStr.c_str())), seedStr.size());
	//cout << "Hashed: " << hex << hashed << endl;
	seed = stringToUnsignedInt(hashed); // takes only 4 bytes from the hashed digest
    	//cout << "Seed: " << dec<<  seed << endl;
	rng1.seed(seed);
	rng2.seed(seed);
	max = n;
	dist = std::uniform_int_distribution<size_t>(0, max-1);
	c = 0;
}
	
size_t getRandomZn::getElement(){
	size_t val;
	val = dist(rng1);
	return val;
}
	
size_t getRandomZn::getElementUnique(){
	size_t val;
	if(c == max){
		cerr << "Error! Cannot Generate More Unique no.s - n numbers already returned." << endl;
		exit(1);
	}
		
	while(1){
		val = dist(rng2);
		if (uniqueNumbers.insert(val).second) {
			break;
		}
	}
	c++;
	return val;
}

/*                          Member Functions of the getRandomFq Class                   */

 	
getRandomFq::getRandomFq(string seed_str, Integer modulus){
	str1 = seed_str;
	q = modulus;
	hashedData = (unsigned char *) malloc(hashedLength);
}
	
Integer getRandomFq::getElement(){
	Integer res;
	str2 = to_string(var++);;
	input_to_hash = str1 + str2;
	hashData(hashedData, hashedLength, reinterpret_cast<unsigned char*> (&input_to_hash[0]), input_to_hash.size() );
	res = MapWordToFiniteField(hashedData, hashedLength, q) ;
	return res;
}



////////////////////////////////////////////////      IMPLEMENTATATION OF THE GLOBAL FUNCTIONS ///////////////////////////////////////////////////////////////

// MapWordToFiniteField()

Integer 
MapWordToFiniteField(const  unsigned char* buffer, size_t wordSize, Integer q) {
    Integer result;
    CryptoPP::byte* resbuffer = (CryptoPP::byte *) malloc(wordSize);
    memcpy(resbuffer, buffer, wordSize);
    result.Decode(resbuffer, wordSize);
    result = (result).Modulo(q);
    //cout << dec<< "Result = " << result << endl;
    free(resbuffer);
    return result;
}


// GenerateKeyMatrix()

vector<vector<Integer>>  
GenerateKeyMatrix(Integer alpha, size_t r, MyFiniteField& Fq){
	vector<vector<Integer>> key_matrix(r, vector<Integer>(1));
	
	key_matrix[0][0] = alpha;
    
    	for (size_t i = 1; i < r; ++i) {
           key_matrix[i][0] = Fq.Mul(key_matrix[i-1][0], alpha);
    	}
    
	return key_matrix;
}

//   ConvertSectorsInFq()

vector<Integer> ConvertSectorsInFq(char * binaryBlock, size_t blocksize, size_t sectorSize, Integer q){
    		char * ptr;
    		size_t sectorCount = (blocksize / sectorSize);
    		vector<Integer> block(sectorCount);  	
	    		
	    	// Extract the 's' sectors from the given binaryBlock and convert each sector-data into an element in Fq and store those in block[0] to block[s-1]
    		ptr  = binaryBlock;
    		for(size_t j = 0; j < sectorCount; j++){
	    		block[j] = MapWordToFiniteField(reinterpret_cast<unsigned char*> (&ptr[0]), sectorSize, q);
	     		ptr = (ptr + sectorSize);
		}
		
		return block;
}


